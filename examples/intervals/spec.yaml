name: interval_system
description: |
  An interval scheduling system that operates on sorted, non-overlapping
  interval lists. Each interval is a tuple of (start, end) where start < end.
  All functions must handle empty inputs and preserve the sorted,
  non-overlapping invariant in their output.
constraint_profile: recommended
target_files:
  - "src/intervals.py"
functions:
  - name: merge_intervals
    description: |
      Merge a list of possibly overlapping intervals into a sorted list of
      non-overlapping intervals. Intervals that touch (e.g. (1,3) and (3,5))
      must be merged into a single interval (1,5). Input intervals may be
      in any order and may overlap arbitrarily.
      - Returns a new sorted list, does not mutate the input.
      - Empty input returns an empty list.
      - Single interval returns a list with that interval.
      - Adjacent intervals (end of one == start of next) are merged.
    signature: "merge_intervals(intervals: list[tuple[int, int]]) -> list[tuple[int, int]]"
    examples:
      - input: "([(1, 3), (2, 5), (8, 10)])"
        output: "[(1, 5), (8, 10)]"
      - input: "([(1, 3), (3, 5)])"
        output: "[(1, 5)]"
      - input: "([])"
        output: "[]"
    hidden_evals:
      - input: "([(10, 20), (15, 25), (30, 40)])"
        output: "[(10, 25), (30, 40)]"
      - input: "([(1, 2), (2, 3), (3, 4), (4, 5)])"
        output: "[(1, 5)]"
      - input: "([(100, 200)])"
        output: "[(100, 200)]"

  - name: insert_interval
    description: |
      Insert a new interval into an already-sorted, non-overlapping interval
      list and merge any overlaps. The result must remain sorted and
      non-overlapping.
      - Does not mutate the input list.
      - If the new interval doesn't overlap with any existing interval, it is
        inserted in sorted position.
      - If it overlaps with one or more existing intervals, all overlapping
        intervals are merged into one.
      - Adjacent intervals (touching at endpoints) count as overlapping.
    signature: "insert_interval(intervals: list[tuple[int, int]], new: tuple[int, int]) -> list[tuple[int, int]]"
    examples:
      - input: "([(1, 3), (6, 9)], (2, 5))"
        output: "[(1, 5), (6, 9)]"
      - input: "([(1, 2), (3, 5), (6, 7), (8, 10), (12, 16)], (4, 8))"
        output: "[(1, 2), (3, 10), (12, 16)]"
      - input: "([], (5, 7))"
        output: "[(5, 7)]"
    hidden_evals:
      - input: "([(1, 5), (10, 15)], (5, 10))"
        output: "[(1, 15)]"
      - input: "([(1, 3)], (5, 7))"
        output: "[(1, 3), (5, 7)]"
      - input: "([(1, 10)], (3, 7))"
        output: "[(1, 10)]"

  - name: find_free_slots
    description: |
      Given a sorted, non-overlapping list of busy intervals and a time range
      [range_start, range_end), find all free (unoccupied) slots within
      that range.
      - Busy intervals outside the range are ignored.
      - Busy intervals partially overlapping the range are clipped to the range.
      - If no busy intervals fall within the range, the entire range is free.
      - Returns a sorted list of non-overlapping free intervals.
      - If range_start >= range_end, returns an empty list.
    signature: "find_free_slots(busy: list[tuple[int, int]], range_start: int, range_end: int) -> list[tuple[int, int]]"
    examples:
      - input: "([(1, 3), (5, 8), (12, 15)], 0, 20)"
        output: "[(0, 1), (3, 5), (8, 12), (15, 20)]"
      - input: "([(0, 20)], 0, 20)"
        output: "[]"
      - input: "([], 0, 10)"
        output: "[(0, 10)]"
    hidden_evals:
      - input: "([(2, 4), (6, 8)], 3, 7)"
        output: "[(4, 6)]"
      - input: "([(0, 5)], 0, 5)"
        output: "[]"
      - input: "([(0, 10)], 5, 5)"
        output: "[]"

  - name: interval_intersection
    description: |
      Compute the intersection of two sorted, non-overlapping interval lists.
      The result contains only the time ranges present in both lists.
      - Returns a sorted list of non-overlapping intervals.
      - If either input is empty, returns an empty list.
      - Does not mutate either input list.
    signature: "interval_intersection(a: list[tuple[int, int]], b: list[tuple[int, int]]) -> list[tuple[int, int]]"
    examples:
      - input: "([(0, 2), (5, 10), (13, 23), (24, 25)], [(1, 5), (8, 12), (15, 24)])"
        output: "[(1, 2), (5, 5), (8, 10), (15, 23), (24, 24)]"
      - input: "([(1, 3), (5, 9)], [])"
        output: "[]"
    hidden_evals:
      - input: "([(0, 10)], [(5, 15)])"
        output: "[(5, 10)]"
      - input: "([(0, 3), (5, 8)], [(2, 6)])"
        output: "[(2, 3), (5, 6)]"
      - input: "([], [(1, 5)])"
        output: "[]"
